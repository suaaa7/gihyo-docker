# Docker/Kubernetes 実践コンテナ開発入門

## 1 Dockerの基礎

## 2 Dockerコンテナのデプロイ

### コラム ENTRYPOINTでコマンドの実行の仕方を工夫する

- EPを指定すると、CMDの引数はEPで実行するファイルへの引数になる
- EPはイメージの作成者側でコンテナの用途をある程度制限したい場合に活用する

## 3 実用的なコンテナの構築とデプロイ

- Data Volumeについて、知らないことが多かった

## 4 Swarmによる実践的なアプリケーション構築

## 5 Kubernetes入門

## 6 Kubernetesのデプロイ・クラスタ構築

## 7 Kubernetesの発展的な利用

## 8 コンテナの運用

- Docker/Kubernetesでのロギングの王道
	- アプリケーションのロギングはファイル出力ではなく、全て標準出力とする
		- コンテナ運用前提であれば、ファイル出力のサポートすら不要
	- nginx等のミドルウェアのログも全て標準出力できるようにDockerイメージを構築する
	- 標準出力するログは全てJSON形式で出力し、それぞれの属性で検索や集計をしやすくする
	- Kubernetesにおいては、fluentd/fluentd-kubernetes-daemonsetで構成されるPodをDaemonSetで各ホストに配置する
	- Kubernetesのリソースにはラベルを適切に設定することで、ログの検索性を確保する

## 9 より軽量なDockerイメージを作る

- イメージサイズの増大で発生する弊害
	- 以下の時間が増大
		- イメージのビルド時間
		- イメージをDocker Registryへプッシュする時間
		- コンテナを実行したいホスト・ノードへのイメージダウンロード時間
	- それにより
		- k8s等のコンテナクラスタを構成するNodeのディスクの消費
		- CI時間の増大
		- トライアンドエラーのしにくさ、生産性の低下
		- オートスケールでコンテナがサービスインされるまでの時間が長くなる
- 軽量なベースイメージ
	- scratch
		- Dockerイメージの始祖
		- Goならビルドしたバイナリファイルのみで実行可能
	- BusyBox
		- 組み込み系システムで多く利用されているLinuxのディストリビューション
		- 非常にサイズが小さいOSであることが特徴
	- Alpine Linux
		- BusyBoxをベースに作成されたディストリビューション
		- 「セキュリティ、シンプルさ、リソース効率を重視するパワーユーザー」向けに設計されている
		- パッケージマネージャapkを使える
- 軽量なイメージを作るために
	- .dockerignoreを活用する
	- レイヤーの数を極力減らす
		- RUNを&&でまとめ、1回のRUNで実行することで、イメージのレイヤーを削減できる
		- &&, スラッシュなどにより可読性とのトレードオフが発生する
	- multi-stage builds
		- ビルド成果物を生成するためのビルドコンテナと、
		- 出来上がったビルド成果物をデプロイして実行するためのコンテナに分けることができる

```
FROM scratch

COPY hello /

CMD ["/hello"]
```

## 10 Dockerの様々な活用方法

- CLIツール、シェルスクリプトをコンテナで便利に実行できる
- hodolintというCLIツールでDockerfileの書式を検査することができる

```
$ docker container run --rm -i hadolint/hadolint < Dockerfile
```

- 負荷テスト
	- Swarm + Locust

## A セキュリティ

### コンテナへのファイル追加におけるリスク

- ADDよりCOPYを使うことが推奨される
- ADD, RUNでファイルを追加したい場合は、検証ロジックを組み込む
    - (チェックサム情報をイメージのビルド時に確認することで、ファイルの正当性を検証する)
- コンテナ内のアプリ実行ユーザを用意する

```
RUN useradd gihyo
USER gihyo
```

## B Dockerでの開発を支援するツール・サービス

- EKS on Fargateを触ってみたい

## C 主要コマンドまとめ
